// Generated by CoffeeScript 1.6.2
/*
リバーシ。
盤面のクラスと、単純なコンピュータ試行ルーチン２つ。
*/


(function() {
  var AI_First, AI_Gain, AI_Random, Reversi;

  Reversi = (function() {
    var dXY, setMessage, setStatMessage;

    Reversi.STONE_IMAGE_WIDTH = 50;

    Reversi.STONE_IMAGE_HEIGHT = 50;

    Reversi.VOID = 'images/void.jpg';

    Reversi.BLACK = 'images/black.jpg';

    Reversi.WHITE = 'images/white.jpg';

    Reversi.HINT_B = 'images/hintB.jpg';

    Reversi.HINT_W = 'images/hintW.jpg';

    dXY = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];

    function Reversi(core, gameSize, stoneDispWidth) {
      this.gameSize = gameSize != null ? gameSize : 8;
      this.stoneDispWidth = stoneDispWidth != null ? stoneDispWidth : 1.0;
      this.fps = core.fps;
      this.num_stone = this.gameSize * this.gameSize;
      this.scale = this.stoneDispWidth / Reversi.STONE_IMAGE_WIDTH;
      this.SPRITES = [];
      this.BoardState = [];
      this.turn = 1;
      this.start = false;
      this.BlackStone = this.WhiteStone = 0;
      this.players = [0, 0];
      this.records = [];
      this.play_pos = 0;
      this.replay_mode = false;
      core.preload([Reversi.VOID, Reversi.BLACK, Reversi.WHITE, Reversi.HINT_B, Reversi.HINT_W]);
    }

    Reversi.prototype.setCPUs = function(cpus) {
      this.cpus = cpus;
    };

    Reversi.prototype.isInBoard = function(x, y) {
      return (x >= 0) && (x < this.gameSize) && (y >= 0) && (y < this.gameSize);
    };

    Reversi.prototype.xy2pos = function(x, y) {
      return x + y * this.gameSize;
    };

    Reversi.prototype.pos2xy = function(pos) {
      return [pos % this.gameSize, Math.floor(pos / this.gameSize)];
    };

    Reversi.prototype._getSprite = function(pos) {
      var height, stone, width, x, y, _ref, _ref1, _ref2;

      _ref = [Reversi.STONE_IMAGE_WIDTH, Reversi.STONE_IMAGE_HEIGHT], width = _ref[0], height = _ref[1];
      stone = new Sprite(width, height);
      stone.image = new Surface(width * 5, height);
      stone.pos = pos;
      _ref1 = this.pos2xy(pos), x = _ref1[0], y = _ref1[1];
      stone.frame = 0;
      stone.scale(this.scale, this.scale);
      _ref2 = [x * width * this.scale, y * height * this.scale], stone.x = _ref2[0], stone.y = _ref2[1];
      stone.image.draw(enchant.Game.instance.assets[Reversi.VOID], 0, 0, width, height, 0, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.BLACK], 0, 0, width, height, width, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.WHITE], 0, 0, width, height, width * 2, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.HINT_B], 0, 0, width, height, width * 3, 0, width, height);
      stone.image.draw(enchant.Game.instance.assets[Reversi.HINT_W], 0, 0, width, height, width * 4, 0, width, height);
      return stone;
    };

    Reversi.prototype.createBoard = function() {
      var pos, _i, _ref;

      this.SPRITES = [];
      for (pos = _i = 0, _ref = this.num_stone; 0 <= _ref ? _i < _ref : _i > _ref; pos = 0 <= _ref ? ++_i : --_i) {
        this.SPRITES.push(this._getSprite(pos));
      }
      this.firstScene();
      return this.SPRITES;
    };

    Reversi.prototype.firstScene = function() {
      var first, i, _i, _ref;

      for (i = _i = 0, _ref = this.num_stone; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.SPRITES[i].frame = 0;
        this.BoardState[i] = 0;
      }
      first = this.gameSize * (Math.floor(this.gameSize / 2 - 1)) + Math.floor(this.gameSize / 2 - 1);
      this.SPRITES[first].frame = this.SPRITES[first + this.gameSize + 1].frame = 2;
      this.BoardState[first] = this.BoardState[first + this.gameSize + 1] = -1;
      this.SPRITES[first + 1].frame = this.SPRITES[first + this.gameSize].frame = 1;
      this.BoardState[first + 1] = this.BoardState[first + this.gameSize] = 1;
      this.BlackStone = this.WhiteStone = 2;
      return document.myForm.black.value = document.myForm.white.value = 2;
    };

    Reversi.prototype.checkInvert = function() {
      var c, canPuts, ddx, ddy, dx, dy, i, pos, turnX, x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

      canPuts = [];
      turnX = (-1) * this.turn;
      for (pos = _i = 0, _ref = this.num_stone; 0 <= _ref ? _i < _ref : _i > _ref; pos = 0 <= _ref ? ++_i : --_i) {
        if (this.BoardState[pos] === 0) {
          _ref1 = this.pos2xy(pos), x = _ref1[0], y = _ref1[1];
          for (i = _j = 0, _ref2 = dXY.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
            _ref3 = [dXY[i][0], dXY[i][1]], dx = _ref3[0], dy = _ref3[1];
            _ref4 = [1, dx, dy], c = _ref4[0], ddx = _ref4[1], ddy = _ref4[2];
            while (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
              _ref5 = [c + 1, ddx + dx, ddy + dy], c = _ref5[0], ddx = _ref5[1], ddy = _ref5[2];
            }
            if (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === this.turn) && (c > 1)) {
              this.BoardState[pos] = 2;
              this.SPRITES[pos].frame = (this.turn > 0 ? 3 : 4);
              canPuts.push(pos);
              break;
            }
          }
        }
      }
      return canPuts;
    };

    Reversi.prototype.showStone = function(stone, opts) {
      var next_frame, x, y, _ref, _ref1, _ref2;

      if (opts == null) {
        opts = {
          delay: 0,
          turn: this.turn
        };
      }
      _ref = [null, null], x = _ref[0], y = _ref[1];
      if (opts.pos) {
        _ref1 = this.pos2xy(opts.pos), x = _ref1[0], y = _ref1[1];
        _ref2 = [x + 1, y + 1], x = _ref2[0], y = _ref2[1];
      }
      next_frame = opts.turn === 1 ? 1 : 2;
      if ((this.players[0] > 0 && this.players[1] > 0) || (this.replay_mode === true)) {
        console.log("--- showStone[" + x + ", " + y + "] immediatory");
        return stone.frame = next_frame;
      } else {
        if (stone.frame !== 0) {
          console.log("--- showStone[" + x + ", " + y + "] (turn) delay " + opts.delay);
          return stone.tl.delay(opts.delay * this.fps).scaleTo(0.1 * this.scale, this.scale, 0.2 * this.fps).then(function() {
            return this.frame = next_frame;
          }).scaleTo(this.scale, this.scale, this.fps * 0.2);
        } else {
          console.log("--- showStone[" + x + ", " + y + "] (set) delay " + opts.delay);
          return stone.tl.delay(opts.delay * this.fps).then(function() {
            return this.frame = next_frame;
          });
        }
      }
    };

    Reversi.prototype.putStone = function(pos, opts) {
      var c, canPuts, cpuID, cpuPut, ddx, ddy, dx, dy, i, turnPos, turnX, x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;

      if (opts == null) {
        opts = {
          delay: 0,
          turn: this.turn
        };
      }
      if (!this.start) {
        return setMessage("[スタート！]を押してください！");
      } else if ((this.replay_mode === false) && (this.BoardState[pos] !== 2)) {
        return setMessage("置けません！");
      } else {
        for (i = _i = 0, _ref = this.num_stone; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (this.BoardState[i] === 2) {
            this.BoardState[i] = 0;
            this.SPRITES[i].frame = 0;
          }
        }
        _ref1 = this.pos2xy(pos), x = _ref1[0], y = _ref1[1];
        setMessage("(" + (x + 1) + ", " + (y + 1) + ") に置きました！");
        this.recordPlay([this.turn, x + 1, y + 1]);
        turnX = (-1) * this.turn;
        for (i = _j = 0, _ref2 = dXY.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
          _ref3 = [dXY[i][0], dXY[i][1]], dx = _ref3[0], dy = _ref3[1];
          _ref4 = [1, dx, dy], c = _ref4[0], ddx = _ref4[1], ddy = _ref4[2];
          while (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
            _ref5 = [c + 1, ddx + dx, ddy + dy], c = _ref5[0], ddx = _ref5[1], ddy = _ref5[2];
          }
          if (this.isInBoard(x + ddx, y + ddy) && (this.BoardState[this.xy2pos(x + ddx, y + ddy)] === this.turn)) {
            _ref6 = [c - 1, ddx - dx, ddy - dy], c = _ref6[0], ddx = _ref6[1], ddy = _ref6[2];
            while (c > 0) {
              this.BoardState[this.xy2pos(x + ddx, y + ddy)] = this.turn;
              if (this.turn > 0) {
                this.BlackStone++;
                this.WhiteStone--;
              } else {
                this.WhiteStone++;
                this.BlackStone--;
              }
              turnPos = this.xy2pos(x + ddx, y + ddy);
              this.showStone(this.SPRITES[turnPos], {
                delay: opts.delay + 0.3,
                turn: this.turn,
                pos: turnPos
              });
              _ref7 = [c - 1, ddx - dx, ddy - dy], c = _ref7[0], ddx = _ref7[1], ddy = _ref7[2];
            }
          }
        }
        this.BoardState[pos] = this.turn;
        if (!this.SPRITES[pos]) {
          alert(pos);
        }
        this.showStone(this.SPRITES[pos], {
          delay: opts.delay,
          turn: this.turn,
          pos: pos
        });
        if (this.turn > 0) {
          this.BlackStone++;
        } else {
          this.WhiteStone++;
        }
        document.myForm.black.value = this.BlackStone;
        document.myForm.white.value = this.WhiteStone;
        this.turn *= -1;
        canPuts = this.checkInvert();
        if (canPuts.length === 0) {
          setMessage(this.turn > 0 ? "先手はパスです！" : "後手はパスです！");
          this.recordPlay([this.turn, 0, 0]);
          this.turn *= -1;
          canPuts = this.checkInvert();
          if (canPuts.length === 0) {
            setMessage("終了");
            setStatMessage("はじめから");
            return;
          }
        }
        if (((this.turn === 1 && this.players[0] > 0) || (this.turn === -1 && this.players[1] > 0)) && (this.replay_mode === false)) {
          cpuID = this.turn === 1 ? this.players[0] - 1 : this.players[1] - 1;
          cpuPut = this.cpus[cpuID].play(this.BoardState.slice(0), {
            turn: this.turn,
            canPuts: canPuts.slice(0)
          });
          if (cpuPut !== null) {
            return this.putStone(cpuPut, {
              delay: opts.delay + 0.8,
              turn: this.turn
            });
          }
        }
      }
    };

    Reversi.prototype.recordPlay = function(pos) {
      if (!this.replay_mode) {
        if (this.play_pos !== this.records.length) {
          this.records = this.records.slice(0, this.play_pos);
        }
        this.records.push(pos);
        return this.play_pos = this.records.length;
      }
    };

    Reversi.prototype.exitReplay = function() {
      return this.replay_mode = false;
    };

    Reversi.prototype.replay = function(hands, len) {
      var i, pos, _i;

      this.replay_mode = true;
      this.firstScene();
      this.turn = 1;
      if (len < 0) {
        len = 0;
      }
      if (len > hands.length) {
        len = hands.length;
      }
      if (len > 0) {
        for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
          pos = (hands[i][1] - 1) + (hands[i][2] - 1) * this.gameSize;
          if (pos >= 0) {
            this.turn = hands[i][0];
            this.putStone(pos);
          }
        }
      }
      if (len <= 0) {
        setMessage("初期画面を表示しています。");
      }
      this.play_pos = len;
      return this.replay_mode = false;
    };

    Reversi.prototype.historyTop = function() {
      return this.replay(this.records, 0);
    };

    Reversi.prototype.historyLast = function() {
      return this.replay(this.records, this.records.length);
    };

    Reversi.prototype.history = function(step) {
      return this.replay(this.records, this.play_pos + step);
    };

    Reversi.prototype.savePlay = function() {
      return alert(JSON.stringify({
        black: this.BlackStone,
        white: this.WhiteStone,
        play: this.records
      }));
    };

    Reversi.prototype.loadPlay = function() {
      return console.log("未実装");
    };

    Reversi.prototype.setPlayers = function() {
      return this.players = [document.myForm.first.selectedIndex, document.myForm.second.selectedIndex];
    };

    Reversi.prototype.gameStart = function() {
      var canPuts;

      if (!this.start) {
        this.setPlayers();
        this.start = true;
        this.records = [];
        this.play_pos = 0;
        setMessage("ゲームスタート！！");
        setStatMessage("やりなおす");
        canPuts = this.checkInvert();
        if (this.players[0] > 0 && canPuts.length > 0) {
          return this.putStone(this.cpus[this.players[0] - 1].play(this.BoardState.slice(0), {
            turn: this.turn,
            canPuts: canPuts.slice(0)
          }));
        }
      } else {
        if (confirm("本当にやり直しますか？")) {
          this.firstScene();
          this.turn = 1;
          this.start = false;
          setStatMessage("スタート！");
          return setMessage("やりなおしました");
        }
      }
    };

    setMessage = function(msg) {
      return document.myForm.myMsg.value = msg;
    };

    setStatMessage = function(msg) {
      return document.myForm.start.value = msg;
    };

    return Reversi;

  })();

  enchant();

  window.onload = function() {
    var core, game_board_width, game_size, reversi;

    game_size = 8;
    game_board_width = 320;
    core = new Core(game_board_width + 10, game_board_width + 10);
    reversi = new Reversi(core, game_size, Math.floor(game_board_width / game_size));
    this.reversi = reversi;
    reversi.setCPUs([new AI_First(), new AI_Random(), new AI_Gain()].slice(0));
    core.onload = function() {
      var board, stone, _i, _len, _results;

      board = reversi.createBoard();
      _results = [];
      for (_i = 0, _len = board.length; _i < _len; _i++) {
        stone = board[_i];
        core.rootScene.addChild(stone);
        _results.push(stone.addEventListener('touchend', function() {
          reversi.exitReplay();
          reversi.setPlayers();
          return reversi.putStone(this.pos);
        }));
      }
      return _results;
    };
    return core.start();
  };

  AI_First = (function() {
    function AI_First() {}

    AI_First.prototype.play = function(boardState, opts) {
      if (opts == null) {
        opts = {};
      }
      if (opts.canPuts.length === 0) {
        return null;
      } else {
        return opts.canPuts[0];
      }
    };

    return AI_First;

  })();

  AI_Random = (function() {
    function AI_Random() {}

    AI_Random.prototype.play = function(boardState, opts) {
      if (opts == null) {
        opts = {};
      }
      if (opts.canPuts.length === 0) {
        return null;
      } else {
        return opts.canPuts[Math.floor(Math.random() * opts.canPuts.length)];
      }
    };

    return AI_Random;

  })();

  AI_Gain = (function() {
    var dXY;

    function AI_Gain() {}

    dXY = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];

    AI_Gain.prototype.numStone = 64;

    AI_Gain.prototype.gameSize = 8;

    AI_Gain.prototype.play = function(boardState, opts) {
      var ans, gainMax, gains, i, pos, score, turn, _i, _j, _len, _ref, _ref1;

      if (opts == null) {
        opts = {};
      }
      turn = opts.turn;
      ans = null;
      gains = {};
      gainMax = -1;
      for (i = _i = 0, _ref = this.numStone; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (boardState[i] === 2) {
          boardState[i] = 0;
        }
      }
      _ref1 = opts.canPuts;
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        pos = _ref1[_j];
        score = this.putStone(boardState, pos, turn, false);
        if (gainMax < score) {
          gainMax = score;
        }
        if (gains[score]) {
          gains[score].push(pos);
        } else {
          gains[score] = [pos];
        }
      }
      console.log(gains);
      if (gainMax <= 0) {
        return null;
      }
      return gains[gainMax][Math.floor(Math.random() * gains[gainMax].length)];
    };

    AI_Gain.prototype.xy2pos = function(x, y) {
      return x + y * this.gameSize;
    };

    AI_Gain.prototype.pos2xy = function(pos) {
      return [pos % this.gameSize, Math.floor(pos / this.gameSize)];
    };

    AI_Gain.prototype.isInBoard = function(x, y) {
      return (x >= 0) && (x < this.gameSize) && (y >= 0) && (y < this.gameSize);
    };

    AI_Gain.prototype.putStone = function(boardState, pos, turn, doTurn) {
      var c, ddx, ddy, dx, dy, gain, i, turnX, x, y, _i, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

      if (doTurn == null) {
        doTurn = false;
      }
      if (boardState[pos] !== 0) {
        return -1;
      }
      turnX = turn * (-1);
      gain = 0;
      _ref = this.pos2xy(pos), x = _ref[0], y = _ref[1];
      for (i = _i = 0, _ref1 = dXY.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _ref2 = [dXY[i][0], dXY[i][1]], dx = _ref2[0], dy = _ref2[1];
        _ref3 = [1, dx, dy], c = _ref3[0], ddx = _ref3[1], ddy = _ref3[2];
        while (this.isInBoard(x + ddx, y + ddy) && (boardState[this.xy2pos(x + ddx, y + ddy)] === turnX)) {
          _ref4 = [c + 1, ddx + dx, ddy + dy], c = _ref4[0], ddx = _ref4[1], ddy = _ref4[2];
        }
        if (boardState[this.xy2pos(x + ddx, y + ddy)] === turn) {
          _ref5 = [c - 1, ddx - dx, ddy - dy], c = _ref5[0], ddx = _ref5[1], ddy = _ref5[2];
          while (c > 0) {
            if (doTurn) {
              boardState[this.xy2pos(x + ddx, y + ddy)] = turn;
            }
            _ref6 = [c - 1, ddx - dx, ddy - dy], c = _ref6[0], ddx = _ref6[1], ddy = _ref6[2];
            gain++;
          }
        }
      }
      if (doTurn) {
        boardState[pos] = turn;
      }
      return gain;
    };

    return AI_Gain;

  })();

}).call(this);
